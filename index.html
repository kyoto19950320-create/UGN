<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>UGN公式・倫理試験（簡易版）</title>
  <style>
    :root{
      --bg:#0b0f14;
      --card:#101824;
      --muted:#a7b3c2;
      --text:#e8eef6;
      --line:#223047;
      --accent:#7fd1ff;
      --danger:#ff6b6b;
      --ok:#8bffb0;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:linear-gradient(180deg,#070a0f, var(--bg));
      color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif;
    }
    .wrap{max-width:860px; margin:0 auto; padding:18px 14px 28px;}
    .card{
      background:rgba(16,24,36,.92); border:1px solid var(--line);
      border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .row{display:flex; gap:14px; align-items:center; justify-content:space-between; flex-wrap:wrap}
    .title{font-size:18px; font-weight:700; letter-spacing:.02em}
    .muted{color:var(--muted); font-size:13px; line-height:1.6}
    .pill{
      border:1px solid var(--line); border-radius:999px; padding:6px 10px;
      color:var(--muted); font-size:12px; background:rgba(0,0,0,.18)
    }
    .hero{
      width:100%; max-height:320px; object-fit:contain;
      border-radius:14px; border:1px solid var(--line); background:#0a111b;
    }
    .qimg{
      width:100%; max-height:280px; object-fit:contain;
      border-radius:14px; border:1px solid var(--line); background:#0a111b;
    }
    .choices{display:grid; gap:10px; margin-top:14px}
    .choice{
      width:100%; text-align:left; padding:12px 12px; border-radius:12px;
      border:1px solid var(--line); background:rgba(0,0,0,.18);
      color:var(--text); font-size:14px; line-height:1.45;
    }
    .choice.selected{
      border-color:rgba(127,209,255,.9);
      box-shadow:0 0 0 2px rgba(127,209,255,.25) inset;
      background:rgba(127,209,255,.10);
    }
    .choice:active{transform:translateY(1px)}
    .bottom{
      position:sticky; bottom:0; padding:12px 0 0; margin-top:12px;
      background:linear-gradient(180deg, rgba(11,15,20,0), rgba(11,15,20,.85) 35%, rgba(11,15,20,1));
    }
    .btn{
      width:100%; padding:14px 14px; border-radius:14px; border:1px solid var(--line);
      background:rgba(127,209,255,.12); color:var(--text); font-size:15px; font-weight:700;
    }
    .btn:disabled{opacity:.45}
    .tiny{font-size:11px; color:var(--muted)}
    .hr{height:1px; background:var(--line); margin:14px 0}
    .resultGrid{display:grid; gap:12px}
    .resultImg{
      width:100%; max-height:260px; object-fit:contain;
      border-radius:14px; border:1px solid var(--line); background:#0a111b;
    }
    .codeBox{
      border:1px dashed var(--line); border-radius:12px; padding:10px 12px;
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      background:rgba(0,0,0,.18);
    }
    .warn{color:#ffd18b}
    .ok{color:var(--ok)}
  </style>
</head>
<body>
  <div class="wrap">
    <div id="view"></div>
  </div>

<script>
/** =========================
 * 設定
 * ========================= */
const QUICK_LIMIT_MS = 5000; // 逡巡境界：5秒（= 5秒以内を「即答」、超えたら「逡巡」）
const IMG_TOP = "img/top.png";
const IMG_Q = (n)=>`img/q${n}.png`;
const IMG_TYPE = (key)=>`img/types/${key}.png`;

// 10分類キー（あなたのファイル名に合わせている）
const TYPE_KEYS = [
  "Order","Delegator","Utilitarian","Altruist","Bearer",
  "Role","Impulse","Avoider","Anchor","Observer"
];

// 表示文言（結果の総評：UGN口調で淡々と）
const TYPE_DATA = {
  Order:{ jp:"秩序優先型", title:"秩序維持を基準に置く判断", summary:
`命令系統・規範を優先し、現場の混乱を最小化する傾向が強い。
組織運用上の安定戦力となる一方、上位判断が誤っていた場合でも従い続けるリスクを内包する。
運用上は「明確な規則」と「責任所在」を提示すると性能が伸びる。`},
  Delegator:{ jp:"責任限定型", title:"判断を委任する判断", summary:
`判断を上位に委ねることで誤判断を避け、自己の限界を管理する傾向が強い。
指揮不在・通信断の局面で判断停止に陥りやすい点に注意が必要。
運用上は代替プロトコルと、複数の指揮経路を準備することが望ましい。`},
  Utilitarian:{ jp:"功利計算型", title:"結果と効率を優先する判断", summary:
`結果・人数・成功率を基準に、最適化に寄せた判断ができる。
作戦立案・参謀適性が高い一方、「切り捨て」の判断に慣れすぎると現場の信頼を失う可能性がある。
運用上は情緒面の緩衝材となる同伴者の配置が有効。`},
  Altruist:{ jp:"献身行動型", title:"目の前の命に引き寄せられる判断", summary:
`救助・保護行動に出やすく、現場での初動に強い。
ただし救えなかった経験を強く内面化しやすく、自責による自壊リスクが高い。
運用上はケア導線と「失敗を個人の罪にしない」評価設計が重要。`},
  Bearer:{ jp:"自己責任型", title:"背負える範囲で線引きする判断", summary:
`「自分が責任を取れるか」を基準に判断する傾向が強い。
現実的で信頼されやすい一方、限界超過時の折れ方が急激になりうる。
運用上は負荷上限の明文化と休息管理が有効。`},
  Role:{ jp:"役割遵守型", title:"職務と配属を優先する判断", summary:
`立場・役目を優先し、感情と判断を切り分ける傾向が強い。
組織的に扱いやすい一方、人間関係の希薄化や誤解（冷淡視）を招く可能性がある。
運用上は任務定義と交代基準を明確にすること。`},
  Impulse:{ jp:"直感衝動型", title:"直感で踏み込む判断", summary:
`危機対応が速く、瞬間判断に強い。
一方で誘導・心理操作の影響を受けやすく、後付け合理化で判断が固定化される危険がある。
運用上は「止め具」になる相棒・チェック手順の同伴が望ましい。`},
  Avoider:{ jp:"熟慮回避型", title:"二択を避け第三案を探す判断", summary:
`想定外の突破口を見つけやすく、膠着局面で価値が出る。
ただし決断期限がある状況で判断不能に陥る可能性がある。
運用上は制限時間と選択枠の提示、および最後の一押し役の配置が有効。`},
  Anchor:{ jp:"依存安定型", title:"拠り所で安定する判断", summary:
`組織・誰か・仕組みに依存することで判断が安定しやすい。
依存先が崩れると急激に不安定化し、極端な判断に振れる危険がある。
運用上は依存先を単一化しない（複数ロイス・複数指揮）構造が望ましい。`},
  Observer:{ jp:"観測者型", title:"一歩引いて分析する判断", summary:
`状況・利害・流れを俯瞰し、情報収集と分析に強い。
当事者性が薄れやすく、責任を外部に置く癖が出る場合がある。
運用上は明確な権限と責務を与え、最終決断局面では支援を用意すること。`}
};

// 設問（画像：q1〜q5、選択肢：5択）
const QUESTIONS = [
  {
    id:1,
    title:"第1問：見知らぬ命",
    body:"封鎖区域内で、一般市民が1人倒れている。あなたの任務は「情報回収」であり、救助は想定されていない。",
    choices:[
      "任務を優先し、見なかったことにする",
      "状況を確認し、可能なら最低限の救命処置だけ行う",
      "その場で救助を試み、任務は後回しにする",
      "上司に連絡し、判断を仰ぐ",
      "自分が救うべきかどうかを、その人の状態で判断する"
    ],
    map:{1:["Order","Role"],2:["Bearer"],3:["Altruist"],4:["Delegator","Anchor"],5:["Utilitarian","Observer"]}
  },
  {
    id:2,
    title:"第2問：仲間の逸脱",
    body:"同行しているエージェントが、命令を無視して独断行動を取ろうとしている。理由は「このままでは助からない人がいるから」だ。",
    choices:[
      "命令違反として制止する",
      "表向きは止めつつ、裏でフォローする",
      "共に行動し、結果は自分も引き受ける",
      "その判断を尊重し、距離を取る",
      "自分ならどうするかを即座に考え、同じ選択をする"
    ],
    map:{1:["Order","Role"],2:["Observer","Bearer"],3:["Altruist","Bearer"],4:["Delegator","Observer"],5:["Impulse"]}
  },
  {
    id:3,
    title:"第3問：情報の秘匿",
    body:"真実を公表すれば混乱は起きるが、多くの人は救われる可能性がある。秘匿すれば秩序は保たれるが、犠牲は確実に出る。",
    choices:[
      "秘匿を選ぶ。秩序は最優先事項だ",
      "段階的に情報を開示する",
      "すべてを公表し、人々の判断に委ねる",
      "公表の是非を決める立場の人間に委ねる",
      "その情報を「誰が得をするか」で判断する"
    ],
    map:{1:["Order","Role"],2:["Bearer","Observer"],3:["Altruist"],4:["Delegator","Anchor"],5:["Utilitarian","Observer"]}
  },
  {
    id:4,
    title:"第4問：取り返しのつかない選択",
    body:"目の前の選択は、どちらを選んでも誰かの人生を壊す。",
    choices:[
      "被害が少ない方を選ぶ",
      "自分が後悔しない方を選ぶ",
      "役割として与えられた選択をする",
      "どちらも選ばず、第三の可能性を探す",
      "自分が責任を取れる選択だけをする"
    ],
    map:{1:["Utilitarian"],2:["Impulse"],3:["Role","Order"],4:["Avoider"],5:["Bearer"]}
  },
  {
    id:5,
    title:"第5問：自分自身",
    body:"あなたがオーヴァードであることが、公になる可能性が出た。",
    choices:[
      "何があっても隠し通す",
      "必要とあらば明かす",
      "公になる前に、身を引く",
      "組織の判断に従う",
      "公になること自体を、恐れていない"
    ],
    map:{1:["Order","Anchor"],2:["Altruist","Role"],3:["Avoider","Observer"],4:["Delegator"],5:["Impulse","Utilitarian"]}
  }
];

/** =========================
 * 状態
 * ========================= */
let idx = -1;                 // -1:トップ, 0..:設問
let qStart = 0;
let selected = null;
let answers = [];             // {qId, choiceIndex, elapsedMs}
let scores = Object.fromEntries(TYPE_KEYS.map(k=>[k,0]));
let quickCount = 0;           // 即答数
let deliberateCount = 0;

/** =========================
 * 画面描画
 * ========================= */
const view = document.getElementById("view");

function renderTop(){
  idx = -1;
  view.innerHTML = `
    <div class="card">
      <div class="row">
        <div class="title">UGN公式・倫理試験（簡易版）</div>
        <div class="pill">記録：判断傾向 / 反応時間</div>
      </div>
      <div class="hr"></div>
      <img class="hero" src="${IMG_TOP}" alt="top" />
      <div class="hr"></div>
      <div class="muted">
        本試験は正誤を判定するものではありません。<br/>
        あなたの判断傾向（選択内容）と反応時間（即答／逡巡）を、分析のために記録します。<br/><br/>
        <span class="warn">※各設問は、選択肢を何度でも変更できます。</span><br/>
        <span class="warn">※ただし「次へ」を押した時点で回答が確定し、前の設問には戻れません。</span><br/>
        ※試験終了後、結果画面をスクリーンショットで共有してください。
      </div>
      <div class="bottom">
        <button class="btn" onclick="start()">開始する</button>
        <div class="tiny" style="margin-top:10px">逡巡判定：5秒（5秒以内=即答 / 超過=逡巡）</div>
      </div>
    </div>
  `;
  lockHistory();
}

function renderQuestion(){
  const q = QUESTIONS[idx];
  view.innerHTML = `
    <div class="card">
      <div class="row">
        <div class="title">${q.title}</div>
        <div class="pill">${idx+1} / ${QUESTIONS.length}</div>
      </div>
      <div class="hr"></div>
      <img class="qimg" src="${IMG_Q(q.id)}" alt="q${q.id}" />
      <div class="hr"></div>
      <div class="muted">${q.body}</div>

      <div class="choices">
        ${q.choices.map((t,i)=>`
          <button class="choice ${selected===i+1?'selected':''}" onclick="pick(${i+1})">${i+1}. ${escapeHtml(t)}</button>
        `).join("")}
      </div>

      <div class="bottom">
        <button class="btn" ${selected?"" :"disabled"} onclick="next()">次へ（確定）</button>
        <div class="tiny" style="margin-top:10px">
          選択は変更できます。確定すると戻れません。
        </div>
      </div>
    </div>
  `;
  lockHistory();
}

function renderResult(finalType, code, speedNote){
  const d = TYPE_DATA[finalType];
  view.innerHTML = `
    <div class="card">
      <div class="row">
        <div class="title">試験結果</div>
        <div class="pill">スクリーンショット共有</div>
      </div>
      <div class="hr"></div>

      <div class="resultGrid">
        <img class="resultImg" src="${IMG_TYPE(finalType)}" alt="${finalType}" />
        <div style="font-weight:700; font-size:16px;">
          あなたの判断傾向は「${d.title}」に近い
        </div>
        <div class="muted" style="white-space:pre-line">${d.summary}</div>

        <div class="codeBox">
          <div><span class="muted">Result Code</span>：<b>${code}</b></div>
          <div class="${speedNote.includes('即答')?'ok':'warn'}">${speedNote}</div>
        </div>

        <div class="tiny">
          ※ 本結果は保存されません。スクリーンショットを共有してください。<br/>
          ※ ブラウザの戻る／更新で試験が無効化される場合があります。
        </div>

        <button class="btn" onclick="restart()">最初から（再受験）</button>
      </div>
    </div>
  `;
  lockHistory();
}

/** =========================
 * 操作
 * ========================= */
function start(){
  // 初期化
  answers = [];
  scores = Object.fromEntries(TYPE_KEYS.map(k=>[k,0]));
  quickCount = 0;
  deliberateCount = 0;
  idx = 0;
  selected = null;
  qStart = performance.now();
  renderQuestion();
}

function pick(n){
  selected = n; // 変更自由。時間は止めない。
  renderQuestion();
}

function next(){
  const q = QUESTIONS[idx];
  const elapsed = Math.max(0, performance.now() - qStart);

  // 記録
  answers.push({ qId:q.id, choiceIndex:selected, elapsedMs:elapsed });

  // 即答/逡巡
  const isQuick = elapsed <= QUICK_LIMIT_MS;
  if (isQuick) quickCount++; else deliberateCount++;

  // スコアリング：該当タイプに加点（即答は+2、逡巡は+1）
  const weight = isQuick ? 2 : 1;
  const types = q.map[selected] || [];
  for (const t of types){
    if (scores[t] !== undefined) scores[t] += weight;
  }

  // 次へ（戻れない）
  idx++;
  selected = null;

  if (idx >= QUESTIONS.length){
    finalize();
  }else{
    qStart = performance.now();
    renderQuestion();
  }
}

function finalize(){
  // 最大スコアのタイプを選ぶ（同点なら「即答が多い方を優先」→それでも同点なら固定順）
  let best = TYPE_KEYS[0];
  for (const k of TYPE_KEYS){
    if (scores[k] > scores[best]) best = k;
  }
  // 同点処理（固定順でOKだが、少しUGNっぽくする）
  const maxScore = scores[best];
  const tied = TYPE_KEYS.filter(k => scores[k] === maxScore);
  if (tied.length > 1){
    // タイブレーク：Observer > Order > Utilitarian…みたいな「嫌な優先度」を作るならここで。
    // いったん固定順の先頭を採用（必要なら後で調整）
    best = tied[0];
  }

  const speedFlag = quickCount >= 3 ? "Q" : "D"; // 5問中3問以上が即答ならQ
  const code = `${best.slice(0,3).toUpperCase()}-${speedFlag}`;
  const speedNote = (speedFlag==="Q")
    ? "反応傾向：即答寄り（衝動／信念が前に出やすい）"
    : "反応傾向：逡巡寄り（状況判断／責任の検討が入りやすい）";

  renderResult(best, code, speedNote);
}

function restart(){
  renderTop();
}

/** =========================
 * “戻れない”の最低限対策
 * ========================= */
function lockHistory(){
  // 戻るボタン対策：疑似的に「戻っても同じ画面」にする
  try{
    history.pushState({locked:true}, "", location.href);
  }catch(e){}
}

window.addEventListener("popstate", (e)=>{
  // 戻る操作が来たら試験を無効化（UGNっぽい）
  // ここでは「トップに戻す」
  renderTop();
});

/** =========================
 * util
 * ========================= */
function escapeHtml(str){
  return String(str).replace(/[&<>"']/g, s => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[s]));
}

// 初期表示
renderTop();
</script>
</body>
</html>
